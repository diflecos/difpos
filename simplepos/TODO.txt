
- Ver cómo podemos definir una Order como un objeto con métodos de tal forma que cuando haya un evento sobre un Order no tengamos que poner todo el código ahí sino simplemente llamar a uno de los métodos --> igual podemos utilizar los Server methods de Meteor???  --> en ppio está en globals.js para poder manejar el currentOrder mientras lo está introduciendo la vendedora sin necesidad de acudir al servidor pero igual no es buena idea por si luego no valida o algo


- Los botones de borrar en las filas de una tabla tienen que identificar de alguna manera el index del elemento que hablamos. Lo ideal es que Blaze cuando se encuentre un {{#each}} pase a lo de dentro el index pero esto no funciona {{@index}} de momento en meteor.  Mientras arreglan este tema en meteor hay que añadir un index a cada elemento de un array de objetos (por ejemplo los OrderItems de un Order o los PaymentTrxs). El rollo es que esta gestión de los index es un poco coñazo. 

- Desdoblar los métodos de pago para que no se muestren las pestañas (de momento no hay necesidad ya que no aceptamos ni cheques ni cupones y seguramente en esos casos puede ser que quepa todo de todas formas. Se evita un click la dependienta.

- Terminar de revisar y probar el modelo de Order para estar 100% seguros que funciona y replicarlo para todos los otros objetos. La función clone() necesaria para inicializar la instancia a partir de un documento de la BBDD no parece que funcione muy bien, debe haber algún conflicto porque cuando se renombra a clone2 ya no falla parece --> he puesto el contenido de esa función en la parte que se hace el order.find(). Verificar que termine de funcionar el /order/view/id 

- Puede darse la posibilidad de que un order tenga un currency diferente del de la tienda???? Por si acaso los nuevos pedidos se crean con el store.currency y en la vista de un pedido inicializamos el currentOrderCurrency a partir del currentOrder.currency

- Para cada objeto, hay que tomar una decision sobre la forma de operar, eligiendo entre: 
	* operar en el cliente sobre el modelo y luego simplemente dedicarnos en los methods a sincronizar 
	* o operar directamente sobre el servidor  
Por ejemplo en el caso de una Session parece obvio que hay que operar a nivel de servidor (sobre todo porque al hacer un Sesssion.init() o Session.end() es necesario que se almacene la fecha _del_servidor_!
En el caso de un Order parece más interesante igual cerrar toda la venta en el cliente y ya luego copiarla toda entera y finalizada al servidor... aunque igual se puede hacer de otra manera simplemente sincrizando cada elemento que se añade a un order
	
	