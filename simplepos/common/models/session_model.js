/* 
El ciclo de vida de una Session: 
- comienza con el login del usuario. En ese momento se crea con currentSession=new Session(); currentSession.save(); Esto genera un status de 'created'
- a continuación el usuario selecciona la tienda desde la que trabaja, hace el conteo inicial y hace click en esta misma pantalla en 'Verificar' => eso lanza la simulación currentSession.verifyInit() que comprueba con el conteo final de la última sesión de la tienda. 
- si la verificación es correcta (o aunque no lo sea si el usuario está seguro de haber hecho bien el conteo) hace click en 'Iniciar Sesion' => ahí se hace el currentSession.init(store,init_cashcheck) que inicializa estos valores y también el fecha de init y se cambia el status a 'open' y se inicializa la init_verification
- a partir de ese momento el usuario puede introducir operaciones
- por ultimo el usuario hace click en 'Terminar sesión' => le saldrá la pantalla de conteo final
- una vez hecho este conteo final hará click en 'Verificar' y esto lanzará una simulación de la verificación  currentSession.verifyEnd(end_cashcheck)
- si la verificación ha tenido éxito (o aunque no haya tenido éxito si está segura del conteo) hará click en 'Terminar Sesion' y se invocará a currentSession.end(end_cashcheck) que actualizará este valor así como la fecha de end, el status='closed' y el end_verification. El hecho de terminar la sesión implicará automáticamente el logout del usuario

*/

SessionPOS=Astro.Class({
	name: 'SessionPOS',
	collection: Sessions,
	fields: {
		storeId: {
			type: 'object',
			validators: [
				Validators.required(),
			]		
		},
		userId: {
			type: 'object',
			validators: [
				Validators.required(),
			]		
		},
		type: {
			type: 'string',
			validators: [
				Validators.required(),
			]		
		},
		status: {
			type: 'string',
			default: 'created',
			validators: [
				Validators.required(),
			]		
		},
		init: {
			type: 'date',
			validators: [
				Validators.required(),
			]		
		},
		end: {
			type: 'date',
			validators: [
				Validators.required(),
			]		
		},
		init_cashcheck: {
			type: 'object',
			validators: [
				Validators.required(),
			]		
		},
		end_cashcheck: {
			type: 'object',
			validators: [
				Validators.required(),
			]		
		},
		init_verification: {
			type: 'string',
			validators: [
				Validators.required(),
			]		
		},
		end_verification: {
			type: 'string',
			validators: [
				Validators.required(),
			]		
		},
		ip: {
			type: 'string',
			validators: [
				Validators.required(),
			]		
		},
		comment: {
			type: 'string',
			validators: [
				Validators.required(),
			]		
		},
		createdAt: {
			type: 'date',
			validators: [
				Validators.required(),
			]		
		},
		udpatedAt: {
			type: 'date',
			validators: [
				Validators.required(),
			]		
		},
		createdBy: {
			type: 'string',
			validators: [
				Validators.required(),
			]		
		},
		updatedBy: {
			type: 'string',
			validators: [
				Validators.required(),
			]		
		},
	},
	methods: {
		verifyInit: function(init_cashcheck,callback) {
			Meteor.call('sessionVerifyInit',this._id,init_cashcheck,function(error, result){
				// TODO: ver qué hacemos en caso de error!
				if(callback!=undefined) {
					callback();		
				}		
			});	
		},
		verifyEnd: function(end_cashcheck,callback) {
			Meteor.call('sessionVerifyEnd',this._id,end_cashcheck,function(error, result){
				// TODO: ver qué hacemos en caso de error!
				if(callback!=undefined) {
					callback();		
				}		
			});	
		},
		initSession: function(init_cashcheck,callback) {
			if(init_cashcheck==undefined) {
				throw new Meteor.Error("session-init_cashcheck-undefined","Session init failed because no initial cashcheck was provided");
			}
			
			Meteor.call('sessionInit',this._id,init_cashcheck,function(error, result){
				// TODO: ver qué hacemos en caso de error!
				if(callback!=undefined) {
					callback();		
				}		
			});	
		},
		endSession: function(end_cashcheck,callback) {
			if(end_cashcheck==undefined) {
				throw new Meteor.Error("session-end_cashcheck-undefined","Session end failed because no end cashcheck was provided");
			}
			
			Meteor.call('sessionEnd',this._id,end_cashcheck,function(error, result){
				// TODO: ver qué hacemos en caso de error!
				if(callback!=undefined) {
					callback();		
				}		
			});	
		},
		last: function(storeId) {   // Metodo estático (simplemente no ponemos prototype en la definición )
			if(storeId==undefined) {
				throw new Meteor.Error("session_last-storeId-undefined","Session.last() failed because no storeId was provided");
			}
			
			var last_session=Sessions.findOne({ "storeId": storeId },{ sort: {"init": "desc"}});
			
			return last_session;
		},
		operations: function() {    // Implementar como relación??!!!!
			// Ver cómo haríamos para devolver todas las operaciones asociadas a la sesión ordenadas temporalmente y cómo puede saber la template que las pinte de qué tipo de operación es cada registro (para pintar unos datos u otros en función de si es un order, una entrada de dinero, etc)
			return; 
		},
		trxs: function() { // Implementar como relación??!!!!
			// Ver cómo haríamos para devolver todas las trx asociadas a la sesión ordenadas temporalmente y cómo puede saber la template que las pinte de qué tipo de trx es cada registro (para pintar unos datos u otros en función de si es un efectivo, una operación con tarjeta, etc)   --> hay que tener en cuanta que las entradas y salidas de dinero también deberían estar asociadas a una trx
			return; 
		},
	}
});

